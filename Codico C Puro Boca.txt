Claro! Vamos desenvolver um código em C que cria dois subprocessos que se comunicam através de pipes IPC (Inter-Process Communication) e utilizam threads. Para tornar o exemplo mais interessante, vamos criar uma aplicação onde um subprocesso gera números aleatórios e o outro subprocesso calcula a soma desses números. Além disso, utilizaremos uma thread para ler e imprimir os resultados.

Aqui está um exemplo de como você pode fazer isso:

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <time.h>
#include <sys/types.h>
#include <sys/wait.h>

#define BUFFER_SIZE 10

int pipefd[2];
pthread_mutex_t mutex;

void* read_and_print(void* arg) {
    int sum;
    while (1) {
        pthread_mutex_lock(&mutex);
        read(pipefd[0], &sum, sizeof(sum));
        pthread_mutex_unlock(&mutex);
        printf("Soma recebida: %d\n", sum);
        if (sum == -1) break; // Sinal para terminar
    }
    return NULL;
}

void generate_numbers() {
    srand(time(NULL));
    int num;
    for (int i = 0; i < BUFFER_SIZE; i++) {
        num = rand() % 100;
        write(pipefd[1], &num, sizeof(num));
        sleep(1); // Simula tempo de processamento
    }
    num = -1; // Sinal para terminar
    write(pipefd[1], &num, sizeof(num));
}

void calculate_sum() {
    int num, sum = 0;
    while (1) {
        read(pipefd[0], &num, sizeof(num));
        if (num == -1) break; // Sinal para terminar
        sum += num;
        pthread_mutex_lock(&mutex);
        write(pipefd[1], &sum, sizeof(sum));
        pthread_mutex_unlock(&mutex);
    }
    sum = -1; // Sinal para terminar
    pthread_mutex_lock(&mutex);
    write(pipefd[1], &sum, sizeof(sum));
    pthread_mutex_unlock(&mutex);
}

int main() {
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pthread_mutex_init(&mutex, NULL);

    pid_t pid1 = fork();
    if (pid1 == 0) {
        // Primeiro subprocesso: gera números
        close(pipefd[0]); // Fecha a leitura
        generate_numbers();
        close(pipefd[1]); // Fecha a escrita
        exit(EXIT_SUCCESS);
    }

    pid_t pid2 = fork();
    if (pid2 == 0) {
        // Segundo subprocesso: calcula a soma
        close(pipefd[1]); // Fecha a escrita
        calculate_sum();
        close(pipefd[0]); // Fecha a leitura
        exit(EXIT_SUCCESS);
    }

    // Processo pai: cria a thread para ler e imprimir
    pthread_t thread;
    pthread_create(&thread, NULL, read_and_print, NULL);

    // Espera os subprocessos terminarem
    wait(NULL);
    wait(NULL);

    // Espera a thread terminar
    pthread_join(thread, NULL);

    pthread_mutex_destroy(&mutex);
    close(pipefd[0]);
    close(pipefd[1]);

    return 0;
}
Explicação do Código:
Pipes IPC: Utilizamos pipefd para criar um pipe que permite a comunicação entre processos.
Threads: Criamos uma thread que lê os resultados do pipe e imprime na tela.
Subprocessos: Utilizamos fork() para criar dois subprocessos. O primeiro gera números aleatórios e o segundo calcula a soma desses números.
Sincronização: Utilizamos um mutex (pthread_mutex_t) para garantir que a leitura e escrita no pipe sejam feitas de forma segura.
Compilação e Execução:
Para compilar e executar o código, use os seguintes comandos no terminal Linux:

gcc -o ipc_example ipc_example.c -lpthread
./ipc_example
Espero que isso ajude! Se tiver alguma dúvida ou precisar de mais alguma coisa, estou à disposição.